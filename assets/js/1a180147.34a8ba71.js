"use strict";(self.webpackChunkmirage_docs=self.webpackChunkmirage_docs||[]).push([[1183],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=p(t),m=o,g=d["".concat(l,".").concat(m)]||d[m]||u[m]||r;return t?a.createElement(g,s(s({ref:n},c),{},{components:t})):a.createElement(g,s({ref:n},c))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,s=new Array(r);s[0]=d;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var p=2;p<r;p++)s[p]=t[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},5625:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>p});var a=t(87462),o=(t(67294),t(3905));const r={sidebar_position:6,title:"Spawn Object - Custom"},s="Custom Spawn Functions",i={unversionedId:"guides/game-objects/spawn-object-custom",id:"guides/game-objects/spawn-object-custom",title:"Spawn Object - Custom",description:"You can use spawn handler functions to customize the default behavior when creating spawned game objects on the client. Spawn handler functions ensure you have full control of how you spawn the game object, as well as how you destroy it.",source:"@site/docs/guides/game-objects/spawn-object-custom.md",sourceDirName:"guides/game-objects",slug:"/guides/game-objects/spawn-object-custom",permalink:"/Mirage/docs/guides/game-objects/spawn-object-custom",draft:!1,editUrl:"https://github.com/MirageNet/Mirage/tree/master/doc/docs/guides/game-objects/spawn-object-custom.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"Spawn Object - Custom"},sidebar:"docs",previous:{title:"Spawn Object",permalink:"/Mirage/docs/guides/game-objects/spawn-object"},next:{title:"Scene Objects",permalink:"/Mirage/docs/guides/game-objects/scene-objects"}},l={},p=[{value:"Setting Up a Game Object Pool with Custom Spawn Handlers",id:"setting-up-a-game-object-pool-with-custom-spawn-handlers",level:2}],c={toc:p};function u(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"custom-spawn-functions"},"Custom Spawn Functions"),(0,o.kt)("p",null,"You can use spawn handler functions to customize the default behavior when creating spawned game objects on the client. Spawn handler functions ensure you have full control of how you spawn the game object, as well as how you destroy it."),(0,o.kt)("p",null,"Use ",(0,o.kt)("inlineCode",{parentName:"p"},"ClientObjectManager.RegisterSpawnHandler")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"ClientObjectManager.RegisterPrefab")," to register functions to spawn and destroy client game objects. The server creates game objects directly and then spawns them on the clients through this functionality. This function takes either the asset ID or a prefab and two function delegates: one to handle creating game objects on the client, and one to handle destroying game objects on the client. The asset ID can be a dynamic one, or just the asset ID found on the prefab game object you want to spawn."),(0,o.kt)("p",null,"The spawn/unspawn delegates will look something like this:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Spawn Handler")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"NetworkIdentity SpawnDelegate(SpawnMessage msg) \n{\n    // do stuff here\n}\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"UnSpawn Handler")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"void UnSpawnDelegate(NetworkIdentity spawned) \n{\n    // do stuff here\n}\n")),(0,o.kt)("p",null,"When a prefab is saved its ",(0,o.kt)("inlineCode",{parentName:"p"},"PrefabHash")," field will be automatically set. If you want to create prefabs at runtime you will have to generate a new Hash instead."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Generate prefab at runtime")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},'// Create a hash that can be generated on both server and client\n// using a string and GetStableHashCode is a good way to do this\nint coinHash = "MyCoin".GetStableHashCode();\n\n// register handlers using hash\nClientObjectManager.RegisterSpawnHandler(creatureHash, SpawnCoin, UnSpawnCoin);\n')),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"The unspawn function may be left as ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),", Mirage will then call ",(0,o.kt)("inlineCode",{parentName:"p"},"GameObject.Destroy")," when the destroy message is received.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Use existing prefab")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"// register handlers using prefab\nClientObjectManager.RegisterPrefab(coin, SpawnCoin, UnSpawnCoin);\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Spawn on Server")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},'int coinHash = "MyCoin".GetStableHashCode();\n\n// spawn a coin - SpawnCoin is called on client\n// pass in coinHash so that it is set on the Identity before it is sent to client\nNetworkServer.Spawn(gameObject, coinHash);\n')),(0,o.kt)("p",null,"The spawn functions themselves are implemented with the delegate signature. Here is the coin spawner. The ",(0,o.kt)("inlineCode",{parentName:"p"},"SpawnCoin")," would look the same, but have different spawn logic:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"public NetworkIdentity SpawnCoin(SpawnMessage msg)\n{\n    return Instantiate(m_CoinPrefab, msg.position, msg.rotation);\n}\npublic void UnSpawnCoin(NetworkIdentity spawned)\n{\n    Destroy(spawned);\n}\n")),(0,o.kt)("p",null,"When using custom spawn functions, it is sometimes useful to be able to unspawn game objects without destroying them. This can be done by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"NetworkServer.Destroy(identity, destroyServerObject: false)"),", making sure that the 2nd argument is false. This causes the object to be ",(0,o.kt)("inlineCode",{parentName:"p"},"Reset")," on the server and sends a ",(0,o.kt)("inlineCode",{parentName:"p"},"ObjectDestroyMessage")," to clients. The ",(0,o.kt)("inlineCode",{parentName:"p"},"ObjectDestroyMessage")," will cause the custom unspawn function to be called on the clients. If there is no unspawn function the object will instead be ",(0,o.kt)("inlineCode",{parentName:"p"},"Destroy")),(0,o.kt)("p",null,"Note that on the host, game objects are not spawned for the local client, because they already exist on the server. This also means that no spawn or unspawn handler functions are called."),(0,o.kt)("h2",{id:"setting-up-a-game-object-pool-with-custom-spawn-handlers"},"Setting Up a Game Object Pool with Custom Spawn Handlers"),(0,o.kt)("p",null,"Here is an example of how you might set up a simple game object pooling system with custom spawn handlers. Spawning and unspawning then puts game objects in or out of the pool."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},'using System.Collections.Generic;\nusing Mirage;\nusing UnityEngine;\n\nnamespace Mirage.Examples\n{\n    public class PrefabPoolManager : MonoBehaviour\n    {\n        [Header("Settings")]\n        public ClientObjectManager clientObjectManager;\n        public int startSize = 5;\n        public int maxSize = 20;\n        public NetworkIdentity prefab;\n\n        [Header("Debug")]\n        [SerializeField] int currentCount;\n\n        Queue<NetworkIdentity> pool;\n\n        void Start()\n        {\n            InitializePool();\n\n            clientObjectManager.RegisterPrefab(prefab, SpawnHandler, UnspawnHandler);\n        }\n\n        // used by clientObjectManager.RegisterPrefab\n        NetworkIdentity SpawnHandler(SpawnMessage msg)\n        {\n            return GetFromPool(msg.position, msg.rotation);\n        }\n\n        // used by clientObjectManager.RegisterPrefab\n        void UnspawnHandler(NetworkIdentity spawned)\n        {\n            PutBackInPool(spawned);\n        }\n\n        void OnDestroy()\n        {\n            clientObjectManager.UnregisterPrefab(prefab);\n        }\n\n        private void InitializePool()\n        {\n            pool = new Queue<NetworkIdentity>();\n            for (int i = 0; i < startSize; i++)\n            {\n                NetworkIdentity next = CreateNew();\n\n                pool.Enqueue(next);\n            }\n        }\n\n        NetworkIdentity CreateNew()\n        {\n            if (currentCount > maxSize)\n            {\n                Debug.LogError($"Pool has reached max size of {maxSize}");\n                return null;\n            }\n\n            // use this object as parent so that objects dont crowd hierarchy\n            NetworkIdentity next = Instantiate(prefab, transform);\n            next.name = $"{prefab.name}_pooled_{currentCount}";\n            next.gameObject.SetActive(false);\n            currentCount++;\n            return next;\n        }\n\n        /// <summary>\n        /// Used to take Object from Pool.\n        /// <para>Should be used on server to get the next Object</para>\n        /// </summary>\n        /// <param name="position"></param>\n        /// <param name="rotation"></param>\n        /// <returns></returns>\n        public NetworkIdentity GetFromPool(Vector3 position, Quaternion rotation)\n        {\n            NetworkIdentity next = pool.Count > 0\n                ? pool.Dequeue() // take from pool\n                : CreateNew(); // create new because pool is empty\n\n            // CreateNew might return null if max size is reached\n            if (next == null) { return null; }\n\n            // set position/rotation and set active\n            next.transform.position = position;\n            next.transform.rotation = rotation;\n            next.gameObject.SetActive(true);\n            return next;\n        }\n\n        /// <summary>\n        /// Used to put object back into pool so they can b\n        /// <para>Should be used on server after unspawning an object</para>\n        /// </summary>\n        /// <param name="spawned"></param>\n        public void PutBackInPool(NetworkIdentity spawned)\n        {\n            // disable object\n            spawned.gameObject.SetActive(false);\n\n            // add back to pool\n            pool.Enqueue(spawned);\n        }\n    }\n}\n')),(0,o.kt)("p",null,"To use this manager, create a new empty game object and add the ",(0,o.kt)("inlineCode",{parentName:"p"},"PrefabPoolManager")," component (code above). Next, drag a prefab you want to spawn multiple times to the Prefab field, and set ",(0,o.kt)("inlineCode",{parentName:"p"},"startSize")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"maxSize")," fields. ",(0,o.kt)("inlineCode",{parentName:"p"},"startSize")," is how many will be spawned when your game starts. ",(0,o.kt)("inlineCode",{parentName:"p"},"maxSize")," is the max number that can be spawned, if this number is reached then an error will be given when trying to more new objects."),(0,o.kt)("p",null,"Finally, set up a reference to the PrefabPoolManager in the script you are using for player movement:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"PrefabPoolManager prefabPoolManager;\n\nvoid Start()\n{\n    prefabPoolManager = FindObjectOfType<PrefabPoolManager>();\n}\n")),(0,o.kt)("p",null,"Your player logic might contain something like this, which moves and fires coins:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},'void Update()\n{\n    if (!isLocalPlayer)\n        return;\n    \n    // move\n    var x = Input.GetAxis("Horizontal") * 0.1f;\n    var z = Input.GetAxis("Vertical") * 0.1f;\n    transform.Translate(x, 0, z);\n\n    // shoot\n    if (Input.GetKeyDown(KeyCode.Space))\n    {\n        // Server RPC Call function is called on the client, but invoked on the server\n        CmdFire();\n    }\n}\n')),(0,o.kt)("p",null,"In the firing logic on the player, make it use the game object pool:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"[ServerRpc]\nvoid CmdFire()\n{\n    // Set up bullet on server\n    NetworkIdentity bullet = prefabPoolManager.GetFromPool(transform.position + transform.forward, Quaternion.identity);\n\n    Rigidbody rigidBody = bullet.GetComponent<Rigidbody>();\n    rigidBody.velocity = transform.forward * 4;\n\n    // tell server to send SpawnMessage, which will call SpawnHandler on client\n    ServerObjectManager.Spawn(bullet);\n\n    // destroy bullet after 2 seconds\n    StartCoroutine(DestroyDelay(bullet, 2.0f));\n}\n\nIEnumerator DestroyDelay(NetworkIdentity go, float delay)\n{\n    yield return new WaitForSeconds(delay);\n\n    // return object to pool on server\n    prefabPoolManager.PutBackInPool(go);\n\n    // tell server to send ObjectDestroyMessage, which will call UnspawnHandler on client\n    ServerObjectManager.Destroy(go, destroyServerObject: false);\n}\n")),(0,o.kt)("p",null,"The Destroy method above shows how to return game objects to the pool so that they can be re-used when you fire again"))}u.isMDXComponent=!0}}]);